{% extends "admin2/base2.html" %}
{% block title %}Order Details{% endblock %}
{% block content %}
<div class="container mx-auto px-4 py-8">
    <h2 class="text-2xl font-bold mb-4">Order Details</h2>
    <table class="min-w-full bg-white border">
        <thead>
            <tr>
                <th class="px-4 py-2 border">s.no</th>
                <th class="px-4 py-2 border">Item</th>
                <th class="px-4 py-2 border">Mobile Number</th>
                <th class="px-4 py-2 border">Qty</th>
                <th class="px-4 py-2 border">Price</th>
                <th class="px-4 py-2 border">Total Price</th>
                <th class="px-4 py-2 border">Date</th>
                <th class="px-4 py-2 border">Time</th>
                <th class="px-4 py-2 border">Status</th>
                <th class="px-4 py-2 border">Actions</th>
            </tr>
        </thead>
        {% regroup orders by email as order_groups %}
        <tbody id="order-food-tbody">
            {% for group in order_groups %}
                <!-- Group header: shows email, item count and "One-time Order" label -->
                <tr class="bg-gray-100">
                    <td class="px-4 py-2 border font-semibold" colspan="9">
                        <div class="flex items-center justify-between">
                            <div>
                                <span class="mr-2">Email:</span>
                                <strong>{{ group.grouper }}</strong>
                                <span class="mx-2 text-sm text-gray-600">({{ group.list|length }} item{% if group.list|length > 1 %}s{% endif %})</span>
                            </div>
                            <div class="text-sm text-gray-600">One-time Order</div>
                        </div>
                    </td>
                </tr>
                <!-- Orders for this email -->
                {% for order in group.list %}
                <tr>
                    <td class="px-4 py-2 border">{{ forloop.counter }}</td>
                    <td class="px-4 py-2 border" x-text="">{{ order.item }}</td>
                    <td class="px-4 py-2 border">{{ order.mobile }}</td>
                    <td class="px-4 py-2 border">{{ order.qty }}</td>
                    <td class="px-4 py-2 border">{{ order.price|floatformat:2 }} CHF</td>
                    <td class="px-4 py-2 border">{{ order.total_price|floatformat:2 }} CHF</td>
                    <td class="px-4 py-2 border">{{ order.created_at|date:"Y-m-d" }}</td>
                    <td class="px-4 py-2 border">{{ order.created_at|time:"H:i:s" }}</td>
                    <td id="status-{{ order.id }}" class="px-4 py-2 border {% if order.status == 'Accepted' %}bg-green-100{% elif order.status == 'Making' %}bg-yellow-100{% elif order.status == 'Ready to Collect' %}bg-blue-100{% elif order.status == 'Delivered' %}bg-purple-100{% elif order.status == 'Cancelled' %}bg-red-100{% endif %}">
                        {{ order.status }}
                    </td>
                    <td class="px-4 py-2 border">
                        <form method="post" action="{% url 'order_action_admin' order.id %}" class="inline order-action-form" data-order-id="{{ order.id }}">
                            {% csrf_token %}
                            <input type="hidden" name="reason" class="cancel-reason-input">
                            <button type="submit" name="action" value="accept" class="bg-green-500 text-white px-2 py-1 rounded text-xs">Accept Order</button>
                            <button type="submit" name="action" value="making" class="bg-yellow-500 text-white px-2 py-1 rounded text-xs">Making Order</button>
                            <button type="submit" name="action" value="collect" class="bg-blue-500 text-white px-2 py-1 rounded text-xs">Collect the Order</button>
                            <button type="submit" name="action" value="delivered" class="bg-purple-500 text-white px-2 py-1 rounded text-xs" onclick="return confirm('Are you sure you want to deliver this order?');">Deliver Order</button>
                            <button type="submit" name="action" value="cancel" class="bg-red-500 text-white px-2 py-1 rounded text-xs cancel-btn">Cancel Order</button>
                        </form>
                    </td>
                </tr>
                {% endfor %}
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- Modal HTML -->
<div id="cancel-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center">
    <div class="bg-white p-6 rounded-lg shadow-xl w-1/3">
        <h3 class="text-lg font-bold mb-4">Reason for Cancellation</h3>
        <textarea id="cancel-reason-textarea" class="w-full p-2 border rounded" rows="4" placeholder="Please provide a reason..."></textarea>
        <div class="mt-4 flex justify-end space-x-2">
            <button id="modal-cancel-btn" class="bg-gray-500 text-white px-4 py-2 rounded">Go Back</button>
            <button id="modal-confirm-btn" class="bg-red-500 text-white px-4 py-2 rounded">Confirm Cancellation</button>
        </div>
    </div>
</div>

<script>
    // Refresh page every 30 seconds
    setInterval(function(){
        window.location.reload();
    }, 30000); // 30 seconds

    // Initialize Firebase
    const firebaseConfig = {
        apiKey: "{{ FIREBASE_API_KEY }}",
        projectId: "{{ FIREBASE_PROJECT_ID }}",
        messagingSenderId: "{{ FIREBASE_SENDER_ID }}",
        appId: "{{ FIREBASE_APP_ID }}"
    };

    firebase.initializeApp(firebaseConfig);
    const messaging = firebase.messaging();

    // Configure Toastr
    toastr.options = {
        closeButton: true,
        progressBar: true,
        positionClass: "toast-top-right",
    };

    // helper to read csrftoken cookie
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    const CSRFTOKEN = getCookie('csrftoken');

    // Handle form submissions
    document.querySelectorAll('.order-action-form').forEach(form => {
        form.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const formData = new FormData(this);
            const action = formData.get('action');
            const orderId = this.dataset.orderId;
            
            try {
                const response = await fetch(this.action, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': CSRFTOKEN
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show toast notification
                    toastr.success(data.message);
                    
                    // Update status cell
                    const statusCell = document.getElementById(`status-${orderId}`);
                    if (statusCell) {
                        statusCell.textContent = data.new_status;
                        updateStatusColor(statusCell, data.new_status);
                    }
                    
                    // Update navbar badge if order count changed
                    if (data.pending_count !== undefined) {
                        updateOrderBadge(data.pending_count);
                    }
                    
                    // Refresh orders table
                    refreshTbody('order-food-tbody');
                } else {
                    toastr.error(data.message || 'An error occurred');
                }
            } catch (error) {
                toastr.error('Failed to process the order');
                console.error('Error:', error);
            }
        });
    });

    function updateOrderBadge(count) {
        const badge = document.getElementById('order-count-badge');
        if (badge) {
            badge.textContent = count;
            badge.style.display = count > 0 ? 'inline-block' : 'none';
        }
    }

    function updateStatusColor(cell, status) {
        cell.className = 'px-4 py-2 border';
        if (status === 'Accepted') cell.classList.add('bg-green-100');
        else if (status === 'Making') cell.classList.add('bg-yellow-100');
        else if (status === 'Ready to Collect') cell.classList.add('bg-blue-100');
        else if (status === 'Delivered') cell.classList.add('bg-purple-100');
        else if (status === 'Cancelled') cell.classList.add('bg-red-100');
    }

    function initCancelModal() {
        const modal = document.getElementById('cancel-modal');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const reasonTextarea = document.getElementById('cancel-reason-textarea');
        const cancelButtons = document.querySelectorAll('.cancel-btn');
        let activeForm = null;

        // detach previous listeners safely by cloning modal (simple reset)
        const modalClone = modal.cloneNode(true);
        modal.parentNode.replaceChild(modalClone, modal);

        // re-select elements from the fresh DOM
        const freshModal = document.getElementById('cancel-modal');
        const freshConfirm = document.getElementById('modal-confirm-btn');
        const freshCancel = document.getElementById('modal-cancel-btn');
        const freshTextarea = document.getElementById('cancel-reason-textarea');

        document.querySelectorAll('.cancel-btn').forEach(button => {
            button.removeAttribute('onclick');
            button.addEventListener('click', function(event) {
                event.preventDefault();
                activeForm = button.closest('form');
                freshModal.style.display = 'flex';
            });
        });

        freshCancel.addEventListener('click', function() {
            freshModal.style.display = 'none';
            freshTextarea.value = '';
        });

        // Use AJAX for confirm so CSRF header is included
        freshConfirm.addEventListener('click', async function() {
            if (!activeForm) return;
            const url = activeForm.action;
            const fd = new FormData(activeForm);
            fd.set('action', 'cancel');
            fd.set('reason', freshTextarea.value || '');

            try {
                const resp = await fetch(url, {
                    method: 'POST',
                    body: fd,
                    credentials: 'same-origin',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': CSRFTOKEN
                    }
                });
                const data = await resp.json();
                if (data.success) {
                    toastr.success(data.message);
                    const orderId = activeForm.dataset.orderId;
                    const statusCell = document.getElementById(`status-${orderId}`);
                    if (statusCell) {
                        statusCell.textContent = data.new_status;
                        updateStatusColor(statusCell, data.new_status);
                    }
                    if (data.pending_count !== undefined) updateOrderBadge(data.pending_count);
                    refreshTbody('order-food-tbody');
                    freshModal.style.display = 'none';
                    freshTextarea.value = '';
                } else {
                    toastr.error(data.message || 'Cancellation failed');
                }
            } catch (err) {
                console.error('Cancel request failed', err);
                toastr.error('Failed to cancel the order');
            }
        });

        freshModal.addEventListener('click', function(event) {
            if (event.target === freshModal) {
                freshModal.style.display = 'none';
                freshTextarea.value = '';
            }
        });
    }

    // Replace tbody by fetching current page and extracting tbody#order-food-tbody
    async function refreshTbody(tbodyId) {
        try {
            const res = await fetch(window.location.href, { headers: { 'X-Requested-With': 'XMLHttpRequest' }});
            if (!res.ok) return;
            const html = await res.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const newTbody = doc.querySelector('#' + tbodyId);
            if (newTbody) {
                const current = document.querySelector('#' + tbodyId);
                if (current && current.innerHTML !== newTbody.innerHTML) {
                    current.innerHTML = newTbody.innerHTML;
                    // re-initialize behaviour for dynamic parts (modal buttons etc.)
                    initCancelModal();
                }
            }
        } catch (e) {
            console.error('refreshTbody error:', e);
        }
    }

    function startRealtimeOrders() {
        const wsProtocol = (location.protocol === 'https:') ? 'wss:' : 'ws:';
        const wsUrl = wsProtocol + '//' + location.host + '/ws/admin/orders/';
        let socket;
        try {
            socket = new WebSocket(wsUrl);
        } catch (e) {
            socket = null;
        }
        if (socket) {
            socket.addEventListener('message', () => refreshTbody('order-food-tbody'));
            socket.addEventListener('close', () => setInterval(() => refreshTbody('order-food-tbody'), 5000));
            socket.addEventListener('error', () => setInterval(() => refreshTbody('order-food-tbody'), 5000));
            // occasional full sync
            setInterval(() => refreshTbody('order-food-tbody'), 15000);
        } else {
            setInterval(() => refreshTbody('order-food-tbody'), 5000);
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        initCancelModal();
        startRealtimeOrders();
    });
</script>
{% endblock %}